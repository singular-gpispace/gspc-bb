<defun name="buchberger">
	<in name="base_filename" type="string" place="place_base_filename"/>
	<in name="library_name" type="string" place="place_library_name"/>

	<in name="input" type="string" place="place_input"/>
	<out name="output" type="string" place="place_output"/>
	<out name="runtime" type="map" place="place_runtime"/>
	<net>
		<place name="place_base_filename" type="string"/>
		<place name="place_library_name" type="string"/>
		<place name="place_input" type="string"/>
		<place name="place_output" type="string"/>
		<place name="place_GB" type="string"/>
		<place name="place_BB_test_fail" type="list"/>
		<place name="place_started_indices" type="list"/>
		<place name="place_runtime" type="map"/>
		<place name="place_eureka_group" type="string">
			<token>
				<value>"DONE"</value>
			</token>
		</place>


		<transition name="init">
			<defun>
				<require key="worker" mandatory="true"/>
       	<in name="base_filename" type="string"/>
				<in name="library_name" type="string"/>
				<in name="input" type="string"/>
				<out name="started_indices" type="list"/>
				<out name="GB" type="string"/>
				<out name="output" type="string"/>
				<out name="runtime" type="map"/>
				<module name="singular_buchberger"
							  require_function_unloads_without_rest="false"
							  function="function_init(runtime, base_filename, library_name, input, started_indices, output, GB)">
				  <cinclude href="interface/buchberger_interface.hpp"/>
					<cinclude href="util-generic/dynamic_linking.hpp"/>
					<cinclude href="boost/variant.hpp"/>
					<cinclude href="iostream"/>
					<cinclude href="chrono"/>
					<cinclude href="boost/thread/thread.hpp"/>
					<code><![CDATA[
						long runtime_start = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
						std::cout << "starting Buchberger Test (at time " << runtime_start << " ms)" << std::endl;

						long runtime_start_singular = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
						std::vector<boost::variant<long,std::string,GpiList>>  args_read, args_in;  std::vector<boost::variant<long*,std::string*,GpiList*>>  args_inout, out;  std::vector<GpiList*>  out_many;
						std::string singular_function_name = "init";
						args_read  = {base_filename};
						args_in    = {input};
						args_inout = {};
						out        = {&output};
						out_many   = {};
						bool delete_files = false;
						bool silent = false;
						RESOLVE_INTERFACE_FUNCTION(singular_buchberger_compute) (library_name, singular_function_name, base_filename, args_read, args_in, args_inout, out, out_many, delete_files, silent);
						long runtime_stop_singular = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
						runtime[(std::string) "Singular init"] = GpiList({-1L, runtime_stop_singular, runtime_stop_singular-runtime_start_singular, 1L});

						std::pair<std::vector<std::vector<int>>,std::string> res = RESOLVE_INTERFACE_FUNCTION(singular_buchberger_get_M_and_F) (library_name, base_filename, input, &runtime);
						std::vector<std::vector<int>> Mvec = res.first;
						GB = res.second;

						long runtime_start_criteria = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();

						// use M to test PC/CC:

						long prodcrit_counter  = 0L;
						long chaincrit_counter = 0L;

						int r = Mvec.size();
						int j=1;
						for (std::vector<std::vector<int>>::iterator Mj=Mvec.begin(); j<=r; ++Mj, j++)
						{
							int i=1;
							for (std::vector<std::vector<int>>::iterator Mi=Mvec.begin(); i<j; ++Mi, i++)
							{
								bool state = true;
								std::vector<int> lcm_i_j = lcm(*Mi, *Mj);
								if (test_PC(*Mi,*Mj)) // apply PC
									{state = false; prodcrit_counter++;}
								else // apply CC
								{
									int k=1;
									for (std::vector<std::vector<int>>::iterator Mk=Mvec.begin(); k<=r; ++Mk, k++)
									{
										if(k!=i && k!=j)
										{
											if (test_CC(lcm_i_j, *Mi, *Mj, *Mk))
											{
												if(k<i)
													{state = false; chaincrit_counter++; break;}
												else { if(k<j)
												{
													std::vector<int> lcm_k_j = lcm(*Mk, *Mj);
													if(!equal(lcm_k_j,lcm_i_j)) {state = false; chaincrit_counter++; break;}
												}
												else // (k>j)
												{
													std::vector<int> lcm_i_k = lcm(*Mi, *Mk);
													std::vector<int> lcm_j_k = lcm(*Mj, *Mk);
													if(!equal(lcm_i_k,lcm_i_j) && !equal(lcm_j_k,lcm_i_j)) {state = false; chaincrit_counter++; break;}
												} }
											}
										}
									}
								}
								if(state==true)
								{
									started_indices.emplace_back(GpiList({(long) i, (long) j}));
								}
							}
						}

						long runtime_stop_criteria = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
						runtime[(std::string) "applying criteria in init transition (Buchberger test)"] = GpiList({-1L, runtime_stop_criteria, runtime_stop_criteria-runtime_start_criteria, 1L});

						std::cout << "STARTED " << started_indices.size() << " S-POLYNOMIAL REDUCTIONS, PRODUCT CRITERION:" << prodcrit_counter << ", CHAIN CRITERION: " << chaincrit_counter << ", TOTAL: " << started_indices.size() + prodcrit_counter + chaincrit_counter << "  (r=" << r << ")" << std::endl;

						long runtime_stop = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
						runtime["TRANSITION "+singular_function_name+" TOTAL"] = GpiList({runtime_start, runtime_stop, runtime_stop-runtime_start, 1L});
						runtime[(std::string) "PRODUCT CRITERION"] = GpiList({-1L, -1L, -1L,  prodcrit_counter});
						runtime[(std::string) "CHAIN CRITERION"] = GpiList({-1L, -1L, -1L, chaincrit_counter});
					]]></code>
				</module>
			</defun>
			<connect-read port="base_filename" place="place_base_filename"/>
			<connect-read port="library_name" place="place_library_name"/>
			<connect-in port="input" place="place_input"/>
			<connect-out-many port="started_indices" place="place_started_indices"/>
			<connect-out port="output" place="place_output"/>
			<connect-out port="GB" place="place_GB"/>
			<connect-out port="runtime" place="place_runtime"/>
		</transition>


	  <transition name="NF_of_spoly">
			<defun>
				<require key="worker" mandatory="true"/>
				<in name="base_filename" type="string"/>
				<in name="library_name" type="string"/>
				<in name="GB" type="string"/>
				<in name="started_indices" type="list"/>
				<out name="BB_test_fail" type="list"/>
				<out name="runtime" type="map"/>
				<in name="eureka_group" type="string"/>
				<out name="eureka" type="set"/>
				<module name="singular_buchberger"
							  require_function_unloads_without_rest="false"
							  function="function_NF_of_spoly(runtime, base_filename, library_name, started_indices, BB_test_fail, eureka_group, eureka, GB)"
								pass_context="true">
					<eureka-group>${eureka_group}</eureka-group>
					<cinclude href="interface/buchberger_interface.hpp"/>
					<cinclude href="util-generic/dynamic_linking.hpp"/>
					<cinclude href="boost/variant.hpp"/>
					<cinclude href="iostream"/>
					<cinclude href="chrono"/>
					<cinclude href="fstream"/>
					<cinclude href="boost/archive/binary_iarchive.hpp"/>
					<cinclude href="boost/archive/binary_oarchive.hpp"/>
					<cinclude href="boost/thread/thread.hpp"/>
					<code><![CDATA[
						long runtime_start = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();

						std::string singular_function_name = "NF_of_spoly";

						long runtime_start_static = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
						static std::pair<ideal,kStrategy> Fstrat = RESOLVE_INTERFACE_FUNCTION(singular_buchberger_get_Fstrat) (library_name, base_filename, GB, &runtime);
						long runtime_stop_static = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
						runtime[(std::string) "reading ideal and kStrategy object (static)"] = GpiList({-1L, runtime_stop_static, runtime_stop_static-runtime_start_static, 1L});
/*
						std::string filename = base_filename+"IO_"+std::to_string(boost::get<long>(started_indices.front()))+"_"+std::to_string(boost::get<long>(started_indices.back()));

						bool cancelled (false) ;

            _pnetc_context->execute_and_kill_on_cancel_DO_NOT_OUTPUT_TO_STANDARD_STREAMS_FROM_WITHIN
                ( [=]
                {
									std::ofstream of (filename,std::ios::binary);
                  boost::archive::binary_oarchive oa (of);

									GpiList BB_test_fail_inner;
									GpiMap runtime_inner;
*/
									bool silent = true;

									fhg::util::scoped_dlhandle
						                            (config::implementation(), RTLD_GLOBAL | RTLD_NOW | RTLD_DEEPBIND)
						                            .sym<decltype (singular_buchberger_compute_NF)> ("singular_buchberger_compute_NF")
						                            (library_name, base_filename, Fstrat, started_indices, &BB_test_fail, &runtime);
/*
									int k=0;
									for (GpiList::iterator it=get_list(runtime_inner[(std::string) "building s-polynomial"]).begin(); k<4; ++it, k++) {oa << boost::get<long>(*it);}
									k=0;
									for (GpiList::iterator it=get_list(runtime_inner[(std::string) "reduction of s-polynomial"    ]).begin(); k<4; ++it, k++) {oa << boost::get<long>(*it);}
									int s = BB_test_fail_inner.size();
									oa << s;

								}
                , [&]
                {
                    cancelled = true;
                }
                , &drts::worker::on_signal_unexpected
                , [] (int exit_code)
                {
                    if (exit_code != 0)
                    {
                        drts::worker::on_exit_unexpected (exit_code);
                    }
                }
            );

						if (!cancelled)
            {
								//std::cout << "reading stream (" << i<<","<<j<<") from file " <<filename<< std::endl;
                std::ifstream is (filename,std::ios::binary);
                boost::archive::binary_iarchive ia (is);

								long tmp,kk;
								GpiList times;
								for (kk=0; kk<4; kk++) {ia >> tmp; times.emplace_back(tmp);}
								runtime[(std::string) "building s-polynomial"] = times;
								GpiList times2;
								for (kk=0; kk<4; kk++) {ia >> tmp; times2.emplace_back(tmp);}
								runtime[(std::string) "reduction of s-polynomial"] = times2;

								int c;
								ia >> c;

								eureka = GpiSet({});
								if(c!=0)
								{
									BB_test_fail.emplace_back(started_indices);
									eureka.insert(eureka_group); // immediately cancel all other NF(spoly)-calculations using eureka
								}
*/
								if (BB_test_fail.size()>0) {eureka.insert(eureka_group);} // immediately cancel all other NF(spoly)-calculations using eureka
								long runtime_stop = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
								runtime["TRANSITION "+singular_function_name+" TOTAL"] = GpiList({runtime_start, runtime_stop, runtime_stop-runtime_start, 1L});
/*
            }

						std::remove(filename.c_str());
*/
					]]></code>
				</module>
			</defun>
			<connect-read port="base_filename" place="place_base_filename"/>
			<connect-read port="library_name" place="place_library_name"/>
			<connect-read port="GB" place="place_GB"/>
			<connect-read port="eureka_group" place="place_eureka_group"/>
			<connect-in port="started_indices" place="place_started_indices"/>
			<connect-out-many port="BB_test_fail" place="place_BB_test_fail"/>
			<connect-out port="runtime" place="place_runtime"/>
			<connect-eureka port="eureka"/>
		</transition>


		<transition name="abort_BB_test">
			<defun>
				<in name="base_filename" type="string"/>
				<in name="library_name" type="string"/>
				<in name="GB" type="string"/>
				<in name="BB_test_fail" type="list"/>
				<in name="eureka_group" type="string"/>
				<out name="eureka" type="set"/>
				<inout name="output" type="string"/>
				<module name="singular_buchberger"
								require_function_unloads_without_rest="false"
								function="function_abortBB_test(base_filename, library_name, GB, BB_test_fail, output, eureka_group, eureka)">
					<cinclude href="interface/buchberger_interface.hpp"/>
					<cinclude href="util-generic/dynamic_linking.hpp"/>
					<cinclude href="boost/variant.hpp"/>
					<cinclude href="iostream"/>
					<cinclude href="chrono"/>
					<cinclude href="fstream"/>
					<cinclude href="boost/archive/binary_iarchive.hpp"/>
					<cinclude href="boost/archive/binary_oarchive.hpp"/>
					<cinclude href="boost/thread/thread.hpp"/>
					<code><![CDATA[

						std::cout << "Buchberger Test FAILED as the ("<<boost::get<long>(BB_test_fail.front())<<","<<boost::get<long>(BB_test_fail.back())<<")-th s-polynomial did not reduce to 0" << std::endl;

						std::vector<boost::variant<long,std::string,GpiList>>  args_read, args_in;  std::vector<boost::variant<long*,std::string*,GpiList*>>  args_inout, out;  std::vector<GpiList*>  out_many;
						std::string singular_function_name = "abort_BB_test";
						args_read  = {};
						args_in    = {BB_test_fail};
						args_inout = {&output};
						out        = {};
						out_many   = {};
						bool delete_files = false;
						bool silent = false;
						RESOLVE_INTERFACE_FUNCTION(singular_buchberger_compute) (library_name, singular_function_name, base_filename, args_read, args_in, args_inout, out, out_many, delete_files, silent);

						eureka = GpiSet({eureka_group});
					]]></code>
				</module>
			</defun>
			<connect-read port="base_filename" place="place_base_filename"/>
			<connect-read port="library_name" place="place_library_name"/>
			<connect-read port="eureka_group" place="place_eureka_group"/>
			<connect-in port="GB" place="place_GB"/>
			<connect-in port="BB_test_fail" place="place_BB_test_fail"/>
			<connect-inout port="output" place="place_output"/>
			<connect-eureka port="eureka"/>
		</transition>
	</net>
</defun>
