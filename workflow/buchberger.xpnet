<defun name="buchberger">
	<include-structs href="structures.xpnet"/>

	<in name="base_filename" type="string" place="place_base_filename"/>
	<in name="library_name" type="string" place="place_library_name"/>
	<in name="nworkers" type="long" place="place_nworkers"/>
	<in name="redSB" type="long" place="place_redSB"/>
	<in name="input" type="string" place="place_input"/>
	<out name="output" type="string" place="place_output"/>
	<net>
		<place name="place_base_filename" type="string"/>
		<place name="place_library_name" type="string"/>
		<place name="place_nworkers" type="long"/>
		<place name="place_nrunning" type="long"/>
		<place name="place_redSB" type="long"/>
		<place name="place_input" type="string"/>
		<place name="place_output" type="string"/>
		<place name="place_BB_finished" type="control"/>
		<place name="place_r" type="long"/>
		<place name="place_M" type="list"/>
		<place name="place_A" type="string"/>
		<place name="place_bookkeeping" type="map"/>
		<place name="place_Q" type="list"/>
		<place name="place_Qback" type="list"/>
		<place name="place_started_indices" type="list"/>
		<place name="place_finished_indices" type="list"/>
		<place name="place_kill_indices" type="string"/>
		<!--place name="place_remainder" type="string"/-->
		<place name="place_NF" type="list"/>
		<place name="place_element_index" type="long"/>
		<!--place name="place_element_index_to_delete" type="long"/-->
		<place name="place_needed_indices" type="long"/>
		<place name="place_needed_indices_list" type="string"/>
		<place name="place_runtime" type="runtimes"/>
		<!--place name="place_reduce_F_limit" type="bool"> <token><value>false</value></token></place-->


		<transition name="init">
			<defun>
				<require key="worker" mandatory="true"/>
       	<in name="base_filename" type="string"/>
				<in name="library_name" type="string"/>
				<in name="input" type="string"/>
				<out name="A" type="string"/>
				<out name="bookkeeping" type="map"/>
				<out name="Q" type="list"/>
				<out name="Qback" type="list"/>
				<out name="r" type="long"/>
				<out name="M" type="list"/>
				<out name="nrunning" type="long"/>
				<out name="runtime" type="runtimes"/>
				<module name="singular_buchberger"
							  require_function_unloads_without_rest="false"
							  function="function_init(runtime, base_filename, library_name, input, A, bookkeeping, nrunning, Q, Qback, r, M)">
				  <cinclude href="interface/buchberger_interface.hpp"/>
					<cinclude href="util-generic/dynamic_linking.hpp"/>
					<cinclude href="boost/variant.hpp"/>
					<cinclude href="iostream"/>
					<cinclude href="chrono"/>
					<cinclude href="boost/thread/thread.hpp"/>

					<code><![CDATA[
						boost::this_thread::sleep_for(boost::chrono::milliseconds(SLEEP_TIME_MS));
						runtime.start = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
						long s_time=0;

						std::list<GpiVariant> innerinnertestlist = {6, 9, (std::string)("fourty-two")};
						std::list<GpiVariant> innertestlist = {6, 9, innerinnertestlist};
						std::list<GpiVariant> testlist = {0, 1, innertestlist};
						long testint = 42;
						std::string teststring = "abc";

						long d;
						std::vector<boost::variant<long,std::string,GpiList>>  args_read, args_in;  std::vector<boost::variant<long*,std::string*,GpiList*>>  args_inout, out;  std::vector<GpiList*>  out_many;
						std::string singular_function_name = "init";
						args_read  = {base_filename};
						args_in    = {input, testlist, testint, teststring};
						args_inout = {};
						out        = {&s_time, &d, &A, &r, &M};
						out_many   = {};
						bool delete_files = false;
						bool silent = false;
						RESOLVE_INTERFACE_FUNCTION(singular_buchberger_compute) (library_name, singular_function_name, base_filename, args_read, args_in, args_inout, out, out_many, delete_files, silent);
						std::cout << "    current_degree after init: " << d << std::endl;
						std::cout << "                                                                                                                                                                                         " << s_time << " ms (" << singular_function_name << ")" << std::endl;
						std::cout << "                                                                                                                                                                                         " << std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count() << " ms (time since epoch)" << std::endl;


						////  QUEUE  //////////
						std::cout << "entering " << singular_function_name << std::endl;
						std::cout << "    r=" << r << std::endl;
						std::cout << "    M:" << std::endl;
						/*
						int ii=0;
						for(GpiList::iterator it=M.begin(); it!=M.end(); ++it)
						{
							ii++; std::cout << "   M" << ii <<":" << std::endl;
							GpiList expvec = get_list(get_list(*it).front());
							for(GpiList::iterator itit=expvec.begin(); itit!=expvec.end(); ++itit)
							{
								std::cout << "     " << boost::get<long>(*itit) << std::endl;
							}
						}*/
						print_variant(M,1);


						int i=1;
						for (GpiList::iterator Mi=M.begin(); i<=r; ++Mi, i++)
						{
							int j=1;
							for (GpiList::iterator Mj=M.begin(); j<i; ++Mj, j++)
							{
								std::cout << "    (i,j)=(" << i << "," << j << ")" << std::endl;

								std::cout << "    M"<<i<<":" << std::endl; print_variant(*Mi,1);
								std::cout << "    M"<<j<<":" << std::endl; print_variant(*Mj,1);
								GpiList lcm_i_j = lcm(*Mi, *Mj);
								int state =  product_criterion(get_list(*Mi), get_list(*Mj));
								bookkeeping[GpiSet({i,j})] = GpiList({state, lcm_i_j, deg(lcm_i_j)}); // A, B, D  --> B,D only needed if leads in same component!
								std::cout << "  state=" << state << std::endl;
								if(state==0)
								{
									std::cout << "   inserting (i,j)=(" << i << "," << j << ") in Q" << std::endl;
									queue_insert(Q, GpiList({i, j, state, lcm_i_j}));
									std::cout << "    Q.size()=" << Q.size() << std::endl;
								}
							}
							// maybe use entries (i,i) for some bookkeeping about the f_i ?
						}
						std::cout <<    "Q: " << std::endl; print_variant(Q,1);

						nrunning = 0L;

						Qback = GpiList({get_list(Q.back()).front(), *std::next(get_list(Q.back()).begin())}); // list(i,j) where (i,j)=spoly at end of Queue

						std::cout << "exiting " << singular_function_name << std::endl;
						///////////////////////


						runtime.transition = singular_function_name;
						runtime.singular = s_time;
						runtime.chaincrit = 0L;
						runtime.stop = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
					]]></code>
				</module>
			</defun>
			<connect-read port="base_filename" place="place_base_filename"/>
			<connect-read port="library_name" place="place_library_name"/>
			<connect-in port="input" place="place_input"/>
			<connect-out port="A" place="place_A"/>
			<connect-out port="bookkeeping" place="place_bookkeeping"/>
			<connect-out port="Q" place="place_Q"/>
			<connect-out port="Qback" place="place_Qback"/>
			<connect-out port="r" place="place_r"/>
			<connect-out port="M" place="place_M"/>
			<connect-out port="nrunning" place="place_nrunning"/>
			<connect-out port="runtime" place="place_runtime"/>
		</transition>


		<transition name="list_indices">
			<defun>
				<require key="worker" mandatory="true"/>
				<in name="base_filename" type="string"/>
				<in name="library_name" type="string"/>
				<in name="nworkers" type="long"/>
				<inout name="A" type="string"/>
				<inout name="nrunning" type="long"/>
				<inout name="bookkeeping" type="map"/>
				<inout name="Q" type="list"/>
				<out name="started_indices" type="list"/>
				<out name="BB_finished" type="list"/>
				<out name="runtime" type="runtimes"/>
				<module name="singular_buchberger"
							  require_function_unloads_without_rest="false"
							  function="function_list_indices(runtime, base_filename, library_name, nworkers, A, nrunning, bookkeeping, Q, started_indices, BB_finished)">
				  <cinclude href="interface/buchberger_interface.hpp"/>
					<cinclude href="util-generic/dynamic_linking.hpp"/>
					<cinclude href="boost/variant.hpp"/>
					<cinclude href="iostream"/>
					<cinclude href="chrono"/>
					<cinclude href="boost/thread/thread.hpp"/>

					<code><![CDATA[
						boost::this_thread::sleep_for(boost::chrono::milliseconds(SLEEP_TIME_MS));
						runtime.start = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
						long s_time=0;
						/*
						long d;
						std::vector<boost::variant<long,std::string,GpiList>>  args_read, args_in;  std::vector<boost::variant<long*,std::string*,GpiList*>>  args_inout, out;  std::vector<GpiList*>  out_many;
						*/std::string singular_function_name = "list_indices";/*
						args_read  = {nworkers};
						args_in    = {};
						args_inout = {&A};
						out        = {&s_time,&d};
						out_many   = {&started_indices, &BB_finished};
						bool delete_files = true;
						bool silent = false;
						RESOLVE_INTERFACE_FUNCTION(singular_buchberger_compute) (library_name, singular_function_name, base_filename, args_read, args_in, args_inout, out, out_many, delete_files, silent);
						std::cout << "current_degree after list_indices: " << d << std::endl;
						std::cout << "                                                                                                                                                                                         " << s_time << " ms (" << singular_function_name << ")" << std::endl;
						*/

						////  QUEUE  //////////
						std::cout << "entering " << singular_function_name << std::endl;
						//std::cout << "    Q before: " << std::endl; print_variant(Q,1);
						for(GpiList::reverse_iterator it=Q.rbegin(); it!=Q.rend(); ++it)
						{
							//std::cout << " ----------------------------- enterig loop -------------------------------- " << std::endl;
							if(nrunning==nworkers) {break;}
							//std::cout << " ----------------------------- 1 -------------------------------- " << std::endl;
							GpiList& Q_entry = get_list(*it);
							GpiList::iterator state = std::next(Q_entry.begin(),2);
							//std::cout << "  (i,j)=(" << boost::get<int>(Q_entry.front()) << "," << boost::get<int>(*std::next(Q_entry.begin(),1)) << "), state:" << (*state).which() << ",  Qi.size() = " << Q_entry.size() << std::endl;
							//std::cout << "   Qi.whiche's = " << (*Q_entry.begin()).which() << ", " << (*std::next(Q_entry.begin(),1)).which() << ", " << (*std::next(Q_entry.begin(),2)).which() << ", " << (*std::next(Q_entry.begin(),3)).which() << std::endl;
							if(boost::get<int>(*state)==0)
							{
								GpiList& entry = get_list(*it);
								int i = boost::get<int>(Q_entry.front());
								int j = boost::get<int>(*std::next(Q_entry.begin()));
								std::cout << "  put index (" << i << "," << j << ") on started_indices" << std::endl;
								// add index (i,j) to job list and change states in Q and bookkeeping:
								/*Q*/started_indices.emplace_back(GpiList({i,j,0}));
								//*std::next(Q_entry.begin(),2) = STARTED;
								boost::get<int>(*state) = STARTED;
								get_list(bookkeeping[GpiSet({i,j})]).front() = STARTED;
								nrunning++;
								std::cout << "  set boost::get<int>(*state) to "                                       << boost::get<int>(*state) << " (should be " << STARTED << ")" << std::endl;
								std::cout << "  set boost::get<int>(*std::next(Q_entry.begin(),2)) to "                << boost::get<int>(*std::next(Q_entry.begin(),2)) << " (should be " << STARTED << ")" << std::endl;
								std::cout << "  set boost::get<int>(get_list(bookkeeping[GpiSet({i,j})]).front()) to " << boost::get<int>(get_list(bookkeeping[GpiSet({i,j})]).front()) << " (should be " << STARTED << ")" << std::endl;
								break;
							}
						}
						if(nrunning==0L)  // ASSUME that if all (i,j) are marked as finished, the Buchberger algorithm is finished (i.e. that there is no lag between writing to A and extending A, atm this is handled in the same transition)
						{
							std::cout << " ----------------------------- Buchberger finished! -------------------------------- " << std::endl;
						/*Q*/	BB_finished.emplace_back(CONTROL_TOKEN);
						}
						//std::cout << "    Q after: " << std::endl; print_variant(Q,1);
						std::cout << "exiting " << singular_function_name << std::endl;
						///////////////////////

						runtime.transition = singular_function_name;
						runtime.singular = s_time;
						runtime.chaincrit = 0L;
						runtime.stop = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
					]]></code>
				</module>
			</defun>
			<connect-read port="base_filename" place="place_base_filename"/>
			<connect-read port="library_name" place="place_library_name"/>
			<connect-read port="nworkers" place="place_nworkers"/>
			<connect-inout port="A" place="place_A"/>
			<connect-inout port="nrunning" place="place_nrunning"/>
			<connect-inout port="bookkeeping" place="place_bookkeeping"/>
			<connect-inout port="Q" place="place_Q"/>
			<connect-out-many port="started_indices" place="place_started_indices"/>
			<connect-out-many port="BB_finished" place="place_BB_finished"/>
			<connect-out port="runtime" place="place_runtime"/>
		</transition>

	  <transition name="NF_of_spoly">
			<defun>
				<require key="worker" mandatory="true"/>
				<in name="base_filename" type="string"/>
				<in name="library_name" type="string"/>
				<in name="r" type="long"/>
				<in name="M" type="list"/>
				<in name="Qback" type="list"/>
				<in name="started_indices" type="list"/>
				<out name="started_indices_out" type="list"/>
				<out name="finished_indices" type="list"/>
				<out name="NF" type="list"/>
				<out name="runtime" type="runtimes"/>
				<module name="singular_buchberger"
							  require_function_unloads_without_rest="false"
							  function="function_NF_of_spoly(runtime, base_filename, library_name, r, M, Qback, started_indices, started_indices_out, finished_indices, NF)">
					<cinclude href="interface/buchberger_interface.hpp"/>
					<cinclude href="util-generic/dynamic_linking.hpp"/>
					<cinclude href="boost/variant.hpp"/>
					<cinclude href="iostream"/>
					<cinclude href="chrono"/>
					<cinclude href="fstream"/>
					<cinclude href="boost/archive/binary_iarchive.hpp"/>
					<cinclude href="boost/archive/binary_oarchive.hpp"/>
					<cinclude href="boost/thread/thread.hpp"/>

					<code><![CDATA[
						boost::this_thread::sleep_for(boost::chrono::milliseconds(SLEEP_TIME_MS));
						runtime.start = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
						long s_time=0;
						long readF_time=0;
/*
						int i = boost::get<int>(started_indices.front());
						int j = boost::get<int>(*std::next(started_indices.begin()));
						int k = boost::get<int>(started_indices.back());
						std::cout << "starting NF with indices =  (" << i << "," << j << "," << k << ")" << std::endl;
*/
						std::cout << "                 and r   = " << r << std::endl;
						std::vector<boost::variant<long,std::string,GpiList>>  args_read, args_in;  std::vector<boost::variant<long*,std::string*,GpiList*>>  args_inout, out;  std::vector<GpiList*>  out_many;
						std::string singular_function_name = "NF_of_spoly";
						args_read  = {base_filename, r, M, Qback};
						args_in    = {started_indices};
						args_inout = {};
						out        = {&s_time, &readF_time};
						out_many   = {&started_indices_out, &finished_indices, &NF};
						bool delete_files = true;
						bool silent = false;
						RESOLVE_INTERFACE_FUNCTION(singular_buchberger_compute) (library_name, singular_function_name, base_filename, args_read, args_in, args_inout, out, out_many, delete_files, silent);
						std::cout << "                                                                                                                                                                                         " << s_time << " ms (" << singular_function_name << ")" << std::endl;

						runtime.transition = singular_function_name;
						runtime.singular = s_time;
						runtime.chaincrit = readF_time;
						runtime.stop = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
					]]></code>
				</module>
			</defun>
			<connect-read port="base_filename" place="place_base_filename"/>
			<connect-read port="library_name" place="place_library_name"/>
			<connect-read port="r" place="place_r"/>
			<connect-read port="M" place="place_M"/>
			<connect-read port="Qback" place="place_Qback"/>
			<connect-in port="started_indices" place="place_started_indices"/>
			<connect-out-many port="started_indices_out" place="place_started_indices"/>
			<connect-out-many port="finished_indices" place="place_finished_indices"/>
			<connect-out-many port="NF" place="place_NF"/>
			<connect-out port="runtime" place="place_runtime"/>
		</transition>


		<!--transition name="NF_of_spoly">
			<defun>
				<require key="worker" mandatory="true"/>
				<in name="base_filename" type="string"/>
				<in name="library_name" type="string"/>
				<in name="r" type="long"/>
				<in name="M" type="list"/>
				<in name="Qback" type="list"/>
				<in name="started_indices" type="list"/>
				<out name="started_indices_out" type="list"/>
				<out name="finished_indices" type="list"/>
				<out name="NF" type="list"/>
				<out name="runtime" type="runtimes"/>
				<module name="singular_buchberger"
							  require_function_unloads_without_rest="false"
							  function="function_NF_of_spoly(runtime, base_filename, library_name, r, M, Qback, started_indices, started_indices_out, finished_indices, NF)">
					<eureka-group>${base_filename}</eureka-group>
					<cinclude href="interface/buchberger_interface.hpp"/>
					<cinclude href="util-generic/dynamic_linking.hpp"/>
					<cinclude href="boost/variant.hpp"/>
					<cinclude href="iostream"/>
					<cinclude href="chrono"/>
					<cinclude href="fstream"/>
					<cinclude href="boost/archive/binary_iarchive.hpp"/>
					<cinclude href="boost/archive/binary_oarchive.hpp"/>
					<cinclude href="boost/thread/thread.hpp"/>

					<code><![CDATA[

						boost::this_thread::sleep_for(boost::chrono::milliseconds(SLEEP_TIME_MS));
						runtime.start = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
						long s_time=0;
						long readF_time=0;

						std::string singular_function_name = "NF_of_spoly";

						// NEW //
						std::string const filename (fhg::util::scoped_dlhandle
																						(implementation, RTLD_GLOBAL | RTLD_NOW | RTLD_DEEPBIND)
																						.sym<decltype (filename_gen)> ("filename_gen")
																						 (base_filename));
						bool cancelled (false) ;

								_pnetc_context->execute_and_kill_on_cancel_DO_NOT_OUTPUT_TO_STANDARD_STREAMS_FROM_WITHIN
										( [=]  // copy parameters
										{
												std::ofstream of (filename,std::ios::binary);
												boost::archive::binary_oarchive oa (of);

												long s_time_dummy, readF_time_dummy;
												GpiList started_indices_out_dummy, finished_indices_dummy, NF_dummy;

												std::cout << "starting NF with indices =  (" << boost::get<int>(started_indices.front()) << "," << boost::get<int>(started_indices.back()) << ")" << std::endl;
												std::cout << "                 and r   = " << r << std::endl;
												std::vector<boost::variant<long,std::string,GpiList>>  args_read, args_in;  std::vector<boost::variant<long*,std::string*,GpiList*>>  args_inout, out;  std::vector<GpiList*>  out_many;

												args_read  = {base_filename, r, M, Qback};
												args_in    = {started_indices};
												args_inout = {};
												out        = {&s_time_dummy, &readF_time_dummy};
												out_many   = {&started_indices_out_dummy, &finished_indices_dummy, &NF_dummy};
												bool delete_files = true;
												bool silent = false;

												(fhg::util::scoped_dlhandle
														(implementation, RTLD_GLOBAL | RTLD_NOW | RTLD_DEEPBIND)
														.sym<decltype (singular_buchberger_compute)> ("singular_buchberger_compute")
														(library_name, singular_function_name, base_filename, args_read, args_in, args_inout, out, out_many, delete_files, silent));
												// save results:
												oa << s_time_dummy;
												oa << readF_time_dummy;
												oa << started_indices_out_dummy;
												oa << finished_indices_dummy;
												oa << NF_dummy;
										}
										, [&]
										{
												cancelled = true;
										}
										, &drts::worker::on_signal_unexpected
										, [] (int exit_code)
										{
												if (exit_code != 0)
												{
														drts::worker::on_exit_unexpected (exit_code);
												}
										}
								);
						if (!cancelled)
						{
								std::ifstream is (filename,std::ios::binary);
								boost::archive::binary_iarchive ia (is);
								// read saved result:
								ia >> s_time;
								ia >> readF_time;
								ia >> started_indices_out;
								ia >> finished_indices;
								ia >> NF;
						}
						// // //

						std::cout << "                                                                                                                                                                                         " << s_time << " ms (" << singular_function_name << ")" << std::endl;

						runtime.transition = singular_function_name;
						runtime.singular = s_time;
						runtime.chaincrit = readF_time;
						runtime.stop = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();

					]]></code>
				</module>
				<condition>
														only need to call the singular proc if r_used<r or ..=.. and (i,j)==Qback
				</condition>
			</defun>
			<connect-read port="base_filename" place="place_base_filename"/>
			<connect-read port="library_name" place="place_library_name"/>
			<connect-read port="r" place="place_r"/>
			<connect-read port="M" place="place_M"/>
			<connect-read port="Qback" place="place_Qback"/>
			<connect-in port="started_indices" place="place_started_indices"/>
			<connect-out-many port="started_indices_out" place="place_started_indices"/>
			<connect-out-many port="finished_indices" place="place_finished_indices"/>
			<connect-out-many port="NF" place="place_NF"/>
			<connect-out port="runtime" place="place_runtime"/>
		</transition-->


		<transition name="increment">
			<defun>
				<require key="worker" mandatory="true"/>
				<in name="base_filename" type="string"/>
				<in name="library_name" type="string"/>
				<in name="NF" type="list"/>
				<inout name="A" type="string"/>
				<inout name="bookkeeping" type="map"/>
				<inout name="Q" type="list"/>
				<inout name="Qback" type="list"/>
				<inout name="r" type="long"/>
				<inout name="M" type="list"/>
				<out name="element_index" type="long"/>
				<out name="finished_indices" type="list"/>
				<out name="kill_indices" type="list"/>
				<out name="runtime" type="runtimes"/>
				<module name="singular_buchberger"
							  require_function_unloads_without_rest="false"
							  function="function_increment(runtime, base_filename, library_name, NF, A, bookkeeping, Q, Qback, r, M, element_index, finished_indices, kill_indices)">
				  <cinclude href="interface/buchberger_interface.hpp"/>
					<cinclude href="util-generic/dynamic_linking.hpp"/>
					<cinclude href="boost/variant.hpp"/>
					<cinclude href="iostream"/>
					<cinclude href="chrono"/>
					<cinclude href="boost/thread/thread.hpp"/>

					<code><![CDATA[
						boost::this_thread::sleep_for(boost::chrono::milliseconds(SLEEP_TIME_MS));
						runtime.start = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
						long s_time=0;
						long ccruntime=0;


						/*
						long d;
						std::vector<boost::variant<long,std::string,GpiList>>  args_read, args_in;  std::vector<boost::variant<long*,std::string*,GpiList*>>  args_inout, out;  std::vector<GpiList*>  out_many;
						*/std::string singular_function_name = "increment";/*
						args_read  = {base_filename};
						args_in    = {NF};
						args_inout = {&A, &r, &M};
						out        = {&s_time, &ccruntime, &element_index, &d, &finished_indices};
						out_many   = {&kill_indices};
						bool delete_files = true;
						bool silent = false;
						RESOLVE_INTERFACE_FUNCTION(singular_buchberger_compute) (library_name, singular_function_name, base_filename, args_read, args_in, args_inout, out, out_many, delete_files, silent);
						std::cout << "current_degree after increment: " << d << std::endl;
						std::cout << "r after increment: " << r << std::endl;
						std::cout << "                                                                                                                                                                                     " << s_time << " ms (" << singular_function_name << ")" << std::endl;
						std::cout << "                                                                                                                                                                                         " << ccruntime << " ms (c/p criterion)" << std::endl;
						std::cout << "                                                                                                                                                                                         " << s_time-ccruntime << " ms (everything else)" << std::endl;
						*/

						////  QUEUE  //////////
						std::cout << "entering " << singular_function_name << std::endl;

						/*Q*/r++;
						GpiList::const_iterator it = NF.begin();
					  //std::string m_temp = boost::get<std::string>(*it); ++it;
					  //std::string f_temp = boost::get<std::string>(*it); ++it;
						GpiVariant index_i = *it; ++it;
					  GpiVariant index_j = *it; ++it;
						GpiVariant m = *it;

						std::cout << "increasing r from " << r-1 << " to " << r << " due to spoly (" << boost::get<long>(index_i) << "," << boost::get<long>(index_j) << ")"<< std::endl;

						/*Q*/M.push_back(m);
						//change filenames:
					  //std::rename((base_filename + m_temp).c_str(), (base_filename+"m"+std::to_string(r)).c_str());
					  //std::rename((base_filename + f_temp).c_str(), (base_filename+"f"+std::to_string(r)).c_str());

					  //update bookkeeping matrix using product + chain criterion
						int j=1;
						for (GpiList::iterator Mj=M.begin(); j<r; ++Mj, j++)
						{
							//std::cout << " ----------------------------- 0 -------------------------------- " << std::endl;
							GpiList lcm_r_j = lcm(m, *Mj);
							int state =  product_criterion(get_list(m), get_list(*Mj));
							bookkeeping[GpiSet({(int)r,j})] = GpiList({state, lcm_r_j, deg(lcm_r_j)}); // A, B, D  --> B,D only needed if leads in same component!
							if(state==0)
							{
								//std::cout << " ----------------------------- 1 -------------------------------- " << std::endl;
								queue_insert(Q, GpiList({(int)r, j, state, lcm_r_j}));
								//std::cout << " ----------------------------- 2 -------------------------------- " << std::endl;
							}
						}
						j=1;
						for (GpiList::iterator Mj=M.begin(); j<r; ++Mj, j++)
						{
							//std::cout << " ----------------------------- 0 -------------------------------- " << std::endl;
							int state =  boost::get<int>(get_list(bookkeeping[GpiSet({(int)r,j})]).front());
							if(state!=0) // spoly(f_r,f_j) can be excluded
							{
								//std::cout << " ----------------------------- 3 -------------------------------- " << std::endl;
								chain_criterion((int)r, j, bookkeeping, kill_indices, M, get_list(m), get_list(*Mj));
							}
						}
						//std::cout << " ----------------------------- after cc -------------------------------- " << std::endl;
						update_queue(Q, bookkeeping, Qback);
						//std::cout << " ----------------------------- after updating Q -------------------------------- " << std::endl;
						//std::cout << " ----------------------------- 5 -------------------------------- " << std::endl;


					  finished_indices = GpiList({index_i, index_j, r});

						std::cout << "exiting " << singular_function_name << std::endl;

						//kill_indices = {};

						///////////////////////

						runtime.transition = singular_function_name;
						runtime.singular = s_time;
						runtime.chaincrit = ccruntime;
						runtime.stop = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
					]]></code>
				</module>
			</defun>
			<connect-read port="base_filename" place="place_base_filename"/>
			<connect-read port="library_name" place="place_library_name"/>
			<connect-in port="NF" place="place_NF"/>
			<connect-inout port="A" place="place_A"/>
			<connect-inout port="bookkeeping" place="place_bookkeeping"/>
			<connect-inout port="Q" place="place_Q"/>
			<connect-inout port="Qback" place="place_Qback"/>
			<connect-inout port="r" place="place_r"/>
			<connect-inout port="M" place="place_M"/>
			<connect-out port="element_index" place="place_element_index"/>
			<connect-out port="finished_indices" place="place_finished_indices"/>
			<connect-out-many port="kill_indices" place="place_kill_indices"/>
			<connect-out port="runtime" place="place_runtime"/>
		</transition>


		<transition name="write_finished_indices_to_A">
			<defun>
				<require key="worker" mandatory="true"/>
				<in name="base_filename" type="string"/>
				<in name="library_name" type="string"/>
				<in name="M" type="list"/>
				<in name="finished_indices" type="list"/>
				<inout name="A" type="string"/>
				<inout name="nrunning" type="long"/>
				<inout name="bookkeeping" type="map"/>
				<inout name="Q" type="list"/>
				<inout name="Qback" type="list"/>
				<out name="kill_indices" type="list"/>
				<out name="runtime" type="runtimes"/>
				<module name="singular_buchberger"
							  require_function_unloads_without_rest="false"
							  function="function_write_finished_indices_to_A(runtime, base_filename, library_name, M, finished_indices, A, nrunning, bookkeeping, Q, Qback, kill_indices)">
				  <cinclude href="interface/buchberger_interface.hpp"/>
					<cinclude href="util-generic/dynamic_linking.hpp"/>
					<cinclude href="boost/variant.hpp"/>
					<cinclude href="iostream"/>
					<cinclude href="chrono"/>
					<cinclude href="boost/thread/thread.hpp"/>

					<code><![CDATA[
						boost::this_thread::sleep_for(boost::chrono::milliseconds(SLEEP_TIME_MS));
						runtime.start = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
						long s_time=0;
						long ccruntime=0;

						/*
						std::vector<boost::variant<long,std::string,GpiList>>  args_read, args_in;  std::vector<boost::variant<long*,std::string*,GpiList*>>  args_inout, out;  std::vector<GpiList*>  out_many;
						*/std::string singular_function_name = "write_finished_indices_to_A";/*
						args_read  = {base_filename, M};
						args_in    = {finished_indices};
						args_inout = {&A};
						out        = {&s_time, &ccruntime};
						out_many   = {&kill_indices};
						bool delete_files = true;
						bool silent = false;
						RESOLVE_INTERFACE_FUNCTION(singular_buchberger_compute) (library_name, singular_function_name, base_filename, args_read, args_in, args_inout, out, out_many, delete_files, silent);
						std::cout << "                                                                                                                                                                                     " << s_time << " ms (" << singular_function_name << ")" << std::endl;
						std::cout << "                                                                                                                                                                                         " << ccruntime << " ms (c/p criterion)" << std::endl;
						std::cout << "                                                                                                                                                                                         " << s_time-ccruntime << " ms (everything else)" << std::endl;
						*/

						////  QUEUE  //////////
						std::cout << "entering " << singular_function_name << std::endl;

						GpiList::const_iterator it = finished_indices.begin();
						int i = (int) boost::get<long>(*it); ++it;
						int j = (int) boost::get<long>(*it); ++it;
						int new_state = (int) boost::get<long>(*it);

						get_list(bookkeeping[GpiSet({i,j})]).front() = new_state;

						chain_criterion(i, j, bookkeeping, kill_indices, M, get_list(*std::next(M.begin(), i-1)), get_list(*std::next(M.begin(), j-1)));

						update_queue(Q, bookkeeping, Qback);

						nrunning--;

						//kill_indices = {};

						std::cout << "exiting " << singular_function_name << std::endl;
						///////////////////////

						runtime.transition = singular_function_name;
						runtime.singular = s_time;
						runtime.chaincrit = ccruntime;
						runtime.stop = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
					]]></code>
				</module>
			</defun>
			<connect-read port="base_filename" place="place_base_filename"/>
			<connect-read port="library_name" place="place_library_name"/>
			<connect-read port="M" place="place_M"/>
			<connect-in port="finished_indices" place="place_finished_indices"/>
			<connect-inout port="A" place="place_A"/>
			<connect-inout port="nrunning" place="place_nrunning"/>
			<connect-inout port="bookkeeping" place="place_bookkeeping"/>
			<connect-inout port="Q" place="place_Q"/>
			<connect-inout port="Qback" place="place_Qback"/>
			<connect-out-many port="kill_indices" place="place_kill_indices"/>
			<connect-out port="runtime" place="place_runtime"/>
		</transition>


		<transition name="minimize_GB">
			<defun>
				<require key="worker" mandatory="true"/>
				<in name="base_filename" type="string"/>
				<in name="library_name" type="string"/>
				<in name="BB_finished" type="control"/>
				<in name="A" type="string"/>
				<in name="r" type="long"/>
				<in name="M" type="list"/>
				<out name="needed_indices_list" type="string"/>
				<out name="output" type="string"/>
				<out name="needed_indices" type="list"/>
				<out name="runtime" type="runtimes"/>
				<module name="singular_buchberger"
							  require_function_unloads_without_rest="false"
							  function="function_minimize_GB(runtime, base_filename, library_name, A, r, M, needed_indices_list, needed_indices, output)">
				  <cinclude href="interface/buchberger_interface.hpp"/>
					<cinclude href="util-generic/dynamic_linking.hpp"/>
					<cinclude href="boost/variant.hpp"/>
					<cinclude href="iostream"/>
					<cinclude href="chrono"/>
					<cinclude href="boost/thread/thread.hpp"/>

					<code><![CDATA[
						boost::this_thread::sleep_for(boost::chrono::milliseconds(SLEEP_TIME_MS));
						runtime.start = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
						long s_time;

						std::vector<boost::variant<long,std::string,GpiList>>  args_read, args_in;  std::vector<boost::variant<long*,std::string*,GpiList*>>  args_inout, out;  std::vector<GpiList*>  out_many;
						std::string singular_function_name = "minimize_GB";
						args_read  = {base_filename};
						args_in    = {A, r, M};
						args_inout = {};
						out        = {&s_time, &needed_indices_list, &output};
						out_many   = {&needed_indices};
						bool delete_files = true;
						bool silent = false;
						RESOLVE_INTERFACE_FUNCTION(singular_buchberger_compute) (library_name, singular_function_name, base_filename, args_read, args_in, args_inout, out, out_many, delete_files, silent);
						std::cout << "                                                                                                                                                                                         " << s_time << " ms (" << singular_function_name << ")" << std::endl;

						runtime.transition = singular_function_name;
						runtime.singular = s_time;
						runtime.chaincrit = 0L;
						runtime.stop = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
					]]></code>
				</module>
			</defun>
			<connect-read port="base_filename" place="place_base_filename"/>
			<connect-read port="library_name" place="place_library_name"/>
			<connect-in port="BB_finished" place="place_BB_finished"/>
			<connect-in port="A" place="place_A"/>
			<connect-in port="r" place="place_r"/>
			<connect-in port="M" place="place_M"/>
			<connect-out port="needed_indices_list" place="place_needed_indices_list"/>
			<connect-out port="output" place="place_output"/>
			<connect-out-many port="needed_indices" place="place_needed_indices"/>
			<connect-out port="runtime" place="place_runtime"/>
		</transition>


		<transition name="reduce_GB">
			<defun>
				<require key="worker" mandatory="true"/>
				<in name="base_filename" type="string"/>
				<in name="library_name" type="string"/>
				<in name="redSB" type="long"/>
				<in name="needed_indices_list" type="string"/>
				<in name="needed_indices" type="long"/>
				<out name="runtime" type="runtimes"/>
				<module name="singular_buchberger"
								require_function_unloads_without_rest="false"
								function="function_reduce_GB(runtime, base_filename, library_name, redSB, needed_indices_list, needed_indices)">
					<cinclude href="interface/buchberger_interface.hpp"/>
					<cinclude href="util-generic/dynamic_linking.hpp"/>
					<cinclude href="boost/variant.hpp"/>
					<cinclude href="iostream"/>
					<cinclude href="chrono"/>
					<cinclude href="boost/thread/thread.hpp"/>

					<code><![CDATA[
						boost::this_thread::sleep_for(boost::chrono::milliseconds(SLEEP_TIME_MS));
						runtime.start = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
						long s_time;

						std::vector<boost::variant<long,std::string,GpiList>>  args_read, args_in;  std::vector<boost::variant<long*,std::string*,GpiList*>>  args_inout, out;  std::vector<GpiList*>  out_many;
						std::string singular_function_name = "reduce_GB";
						args_read  = {base_filename, redSB, needed_indices_list};
						args_in    = {needed_indices};
						args_inout = {};
						out        = {&s_time};
						out_many   = {};
						bool delete_files = true;
						bool silent = false;
						RESOLVE_INTERFACE_FUNCTION(singular_buchberger_compute) (library_name, singular_function_name, base_filename, args_read, args_in, args_inout, out, out_many, delete_files, silent);
						std::cout << "                                                                                                                                                                                         " << s_time << " ms (" << singular_function_name << ")" << std::endl;

						runtime.transition = singular_function_name;
						runtime.singular = s_time;
						runtime.chaincrit = 0L;
						runtime.stop = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
					]]></code>
				</module>
			</defun>
			<connect-read port="base_filename" place="place_base_filename"/>
			<connect-read port="library_name" place="place_library_name"/>
			<connect-read port="redSB" place="place_redSB"/>
			<connect-read port="needed_indices_list" place="place_needed_indices_list"/>
			<connect-in port="needed_indices" place="place_needed_indices"/>
			<connect-out port="runtime" place="place_runtime"/>
		</transition>

		<transition name="summarize_runtimes">
			<defun>
				<require key="worker" mandatory="true"/>
				<in name="base_filename" type="string"/>
				<in name="library_name" type="string"/>
				<in name="runtime" type="runtimes"/>
				<inout name="output" type="string"/>
				<module name="singular_buchberger"
								require_function_unloads_without_rest="false"
								function="function_summarize_runtimes(runtime, base_filename, library_name, output)">
					<cinclude href="interface/buchberger_interface.hpp"/>
					<cinclude href="util-generic/dynamic_linking.hpp"/>
					<cinclude href="boost/variant.hpp"/>
					<cinclude href="iostream"/>
					<cinclude href="chrono"/>
					<code><![CDATA[
						std::vector<boost::variant<long,std::string,GpiList>>  args_read, args_in;  std::vector<boost::variant<long*,std::string*,GpiList*>>  args_inout, out;  std::vector<GpiList*>  out_many;
						std::string singular_function_name = "summarize_runtimes";
						args_read  = {};
						args_in    = {runtime.transition, runtime.start, runtime.stop, runtime.singular, runtime.chaincrit};
						args_inout = {&output};
						out        = {};
						out_many   = {};
						bool delete_files = true;
						bool silent = true;
						RESOLVE_INTERFACE_FUNCTION(singular_buchberger_compute) (library_name, singular_function_name, base_filename, args_read, args_in, args_inout, out, out_many, delete_files, silent);
					]]></code>
				</module>
			</defun>
			<connect-read port="base_filename" place="place_base_filename"/>
			<connect-read port="library_name" place="place_library_name"/>
			<connect-in port="runtime" place="place_runtime"/>
			<connect-inout port="output" place="place_output"/>
		</transition>
	</net>
</defun>
