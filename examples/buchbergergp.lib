///////////////////////////////////////
version="version buchbergergp.lib 0.2 Mar 2023 ";
category="Commutative algebra";
info="
LIBRARY: buchbergergp.lib  procedures for Buchbergers algorithm

OVERVIEW:
    This library contains SINGULAR procedures used in the parallel implementation
    of Buchbergers algorithm in the Singular/GPI-Space framework.
    The newstruct type token  must be defined.

    PROCEDURES:
    init(string,token)                                Initialize (including checking product and chain criterion)
    list_indices(token)                               Return indices ij of A with A_ij=0 and update A_ij, also checks if BB algo is finished
                                                      If A contains no 0 or 1, return an output token with the std basis ('out-many')
    NF_of_spoly(string,int,token)                     Calculate NF(spoly(f_i,f_j),[f_1,...,f_r]) for the given index ij.
                                                      Return ij and the calculated normal form iff it is non-zero ('out-many')
    increment(string,token,token,int)                 Save the new basis element f_(r+1) (as ssi-file) and enlarge A.
                                                      (including checking the product and chain criterion for the new entries)
    write_finished_indices_to_A(string,token,token)   Update A_ij at the specified index and check chain cndition.
    proc minimize_GB(string, token, int)              compute, which elements can be deleted to get a minimal Groebner Basis (GB)
    proc reduce_GB(string,int,token,int)              reduce one element of the minimal GB by all the others to compute a reduced GB
";


proc mod_init()
{
    LIB "polylib.lib";
    LIB "teachstd.lib"; // for spoly
    LIB "general.lib"; // for sort

    // states of entries of A (have to be <2 and !=0):
    int NF_IS_ZERO           =  1;
    int STARTED              = -1;
    int DIFFERENT_COMPONENTS = -2;
    int CHAIN_CRITERION      = -3;
    int PRODUCT_CRITERION    = -4;
    int UNNECESSARY_ELEMENT  = -5;
    system("--ticks-per-sec", 1000000);
    int TTT = 0;
    export(NF_IS_ZERO, STARTED, DIFFERENT_COMPONENTS, CHAIN_CRITERION, PRODUCT_CRITERION, UNNECESSARY_ELEMENT, TTT);
}

// argument order is ALWAYS:
// for inputs:  read  - in  - inout
// for outputs: inout - out - out_many

proc init(string DIR, token input, string test_str)
"USAGE: init(token input)
RETURN: token out_A, token out_r
"
{
//  if(test_str != "1_2") {ERROR("42!");}
//  debug(DIR, test_str, "wtf", "%s");
//  int index_ij = find(test_str,"_");
//  debug(DIR, index_ij, "wtf2", "%s");
//  int ii = int(test_str[1,index_ij-1]);
//  int jj = int(test_str[index_ij+1,size(test_str)]);
//  test_str = string(jj)+"_"+string(ii);


  int time = rtimer;
  def F = input.data[1];
  int out_r = size(F);
  list m;
  intvec e;
  int i,j;
  list M;
  if(typeof(F) == "module") { // module
    int n = nvars(basering);
    for(i=1; i<=out_r; i++)
    {
      write("ssi:w "+DIR+"f"+string(i), F[i]);

      e = leadexp(F[i]);
      m[1] = monomial(intvec(e[1..n])); // lead monomial as poly
      m[2] = e[n+1];                    // the lead monomials component as int (0 in case of polynomials & ideals)
      m[3] = deg(F[i]);                 // degree
      m[4] = size(F[i]);                // number of terms
      m[5] = ecart(F[i]);               // ecart
      write("ssi:w "+DIR+"m"+string(i), m);
      M[i] = m;
    }
  }
  else { // ideal
    for(i=1; i<=out_r; i++)
    {
      write("ssi:w "+DIR+"f"+string(i), F[i]);

      m[1] = leadmonom(F[i]);           // lead monomial as poly
      m[2] = 0;                         // the lead monomials component as int (0 in case of polynomials & ideals)
      m[3] = deg(F[i]);                 // degree
      m[4] = size(F[i]);                // number of terms
      m[5] = ecart(F[i]);               // ecart
      write("ssi:w "+DIR+"m"+string(i), m);
      M[i] = m;
    }
  }

  list kill_indices;
  intmat A[out_r][out_r];
  matrix B[out_r][out_r];
  intmat D[out_r][out_r];
  for(i=1; i<=out_r; i++) {
    A[i,i]=i;
    for(j=i; j<=out_r; j++) {
      B[i,j] = lcm(M[i][1],M[j][1]);
      B[j,i] = B[i,j];
      D[i,j] = deg(B[i,j]);
      D[j,i] = D[i,j];
    }
  }
  export(A, B, kill_indices, M);
  for(i=1; i<=out_r; i++) {product_criterion(i);}  // initialize A using product (and chain) criterion
  // kill_indices can be discarded (and will in fact be empty), as no NF processes have started yet

  int current_degree = -2;
  for(i=1; i<=out_r; i++) {
    for(j=1; j<i; j++) {
      if(A[i,j]==0) {
        if(current_degree==-2 || current_degree > D[i,j]) {current_degree = D[i,j];}
      }
    }
  }

  token out_A;
  out_A.fieldnames[1] = "matrix_A";
  out_A.data[1] = A;
  out_A.fieldnames[2] = "matrix_B";
  out_A.data[2] = B;
  out_A.fieldnames[3] = "matrix_D";
  out_A.data[3] = D;
  out_A.fieldnames[4] = "current_degree";
  out_A.data[4] = current_degree;
  //debug(DIR,out_A,"A_after_init");
  return(rtimer-time, current_degree, out_A, out_r, test_str);
}

proc list_indices(int read_nworkers, token inout_A) // nworkers = number of workers that will be dedicated to the NF_of_spoly transition (assuming no lagging in the book-keeping)
"USAGE: list_indices(token inout_A)
RETURN: token inout_A, list out_many_started_indices, list out_many_BB_finished
"
{
  int time = rtimer;
  intmat A = inout_A.data[1];
  intmat D = inout_A.data[3];
  int current_degree = inout_A.data[4];

  int r = nrows(A);
  list out_many_started_indices;
  token out_started_indices;
  out_started_indices.fieldnames[1] = "started_indices";
  int finished = 1;
  int new_degree = -2;
  int nrunning = 0;
  int i,j,d,a;
  int k=1;
  for(i=1; i<=r; i++)
  {
    for(j=i+1; j<=r; j++)
    {
      if(A[i,j]==STARTED) {nrunning++;} // more efficient: add nrunning to the token of A and update dynamically
    }
  }
  for(i=1; i<=r; i++)
  {
    for(j=i+1; j<=r; j++)
    {
      a = A[i,j];
      d = D[i,j];

      if(a==0) {
        if(new_degree==-2 || new_degree>d) {new_degree = d;}
      }

      if(read_nworkers-nrunning>0 && A[i,j]==0 && D[i,j] == current_degree)
      {
        A[i,j] = STARTED;
        A[j,i] = STARTED;

        out_started_indices.data[1] = intvec(i,j);

        out_many_started_indices[k] = out_started_indices;
        //out_many_started_indices[k] = string(i)+","+string(j);

        k++;
        nrunning++;
      }

      if(a==0 || a==STARTED || a>r) {finished = 0;}
    }
  }
  if(nrunning==0 && k==1 && new_degree!=-2) // if no index is running and no index of current degree can be found:
    {current_degree = new_degree;}          // increase the degree for next call of the procedure


  list out_many_BB_finished;
  if(finished)
  {
    // if finished: put a token on the "BB_finished" place
    // this will trigger the start of the computation of a (unique) reduced GB
    int out_BB_finished=1;
    out_many_BB_finished[1] = out_BB_finished;
  }

  inout_A.data[1] = A;
  inout_A.data[4] = current_degree;
  return(inout_A, rtimer-time, current_degree, out_many_started_indices, out_many_BB_finished);
}



proc NF_init(string DIR, int read_r, token in_started_indices)
{
  int time = rtimer;
  int i,j = in_started_indices.data[1];

  list m1 = read("ssi:r "+DIR+"m1");
  if(m1[2]==0) {poly   fi,fj;}
  else         {vector fi,fj;}
  fi = read("ssi:r "+DIR+"f"+string(i));
  fj = read("ssi:r "+DIR+"f"+string(j));

//  int k;
//  if(m1[2]==0) {ideal F;}
//  else         {module F;}
//  for(k=1; k<=read_r; k++)   {F[k] = read("ssi:r "+DIR+"f"+string(k));}

  token out_remainder;
  out_remainder.fieldnames[1] = "current_remainder";
  out_remainder.data[1] = spoly(fi,fj); //NF(spoly(fi,fj),F);
  out_remainder.fieldnames[2] = "indices";
  out_remainder.data[2] = intvec(i,j);
  out_remainder.fieldnames[3] = "runtime";
  out_remainder.data[3] = 0;
  return(rtimer-time, out_remainder);
}

proc NF_step(string DIR, int read_r, token in_remainder)
{
  int time = rtimer;
  //int ddd = 1;
  //debug(DIR,ddd,string(ddd)); ddd++;


  def R = in_remainder.r_data;
  setring R;

  //debug(DIR,ddd,string(ddd)); ddd++;

  def rem = in_remainder.data[1];

  //debug(DIR,ddd,string(ddd)); ddd++;

  poly q;
  list out_many_remainder, out_many_finished_indices, out_many_NF;

  if(rem!=0) {
    poly rem_lmon;
    int rem_lcomp;
    if(typeof(rem)=="poly") {
      rem_lmon = leadmonom(rem);
      rem_lcomp = 0;
    }
    else {
      int n = nvars(basering);
      intvec e = leadexp(rem);
      rem_lmon = monomial(intvec(e[1..n]));
      rem_lcomp = e[n+1];
    }

    int k;
    list m;
//    list leads, comps, degrees, nterms, ecarts;
    for(k=1; k<=read_r; k++)
    {
      m = read("ssi:r "+DIR+"m"+string(k));
//      leads[k]   = m[1]; // lead monomial (as poly)
//      comps[k]   = m[2]; // lead component (int)
//      degrees[k] = m[3]; // degree
//      nterms[k]  = m[4]; // nterms
//      ecarts[k]  = m[5]; // ecart

//    }

//    //intvec indices = sort(ecarts)[2];
//    //indices = intvec(indices[sort(list(nterms[indices]))[2]]);
//    //indices = intvec(indices[sort(list(degrees[indices]))[2]]);
//
//    for(int kk=1; kk<=read_r; kk++)
//    {
//      k = indices[kk]; // go through the f_k in order from smallest to highest degree (with nterms and ecarts as tie-break)
//      k = kk;

      q = rem_lmon/m[1];   //leads[k]; // quotient if divisible, 0 else (as poly)
      if(q!=0 && rem_lcomp==m[2])   //comps[k]) // use f_k to reduce
      {
        def f = read("ssi:r "+DIR+"f"+string(k));
        if((option(get) % 2^27) >= 2^26) // if option(intStrategy) is activated: dont divide the lead coefficients:
        {
          number f_LC = leadcoef(f);
          number rem_LC = leadcoef(rem);
          number d = gcd(f_LC, rem_LC);
          in_remainder.data[1] = f_LC/d * rem - rem_LC/d * q * f;
          in_remainder.data[1] = in_remainder.data[1] / content(in_remainder.data[1]);
        }
        else
        {
          in_remainder.data[1] = rem - (leadcoef(rem)/leadcoef(f)) * q * f;
        }
        in_remainder.data[3] = in_remainder.data[3] + (rtimer-time);
        out_many_remainder[1] = in_remainder;
        if(rem!=0) {return(rtimer-time, out_many_remainder, out_many_finished_indices, out_many_NF);} // division algorithm not finished ==> put new remainder back to the place "remainder"
      }
    }
  }

  //debug(DIR,ddd,string(ddd)); ddd++;

  if(rem!=0) // non-zero remainder ==> add to the place "NF"
  {
    out_many_NF[1] = in_remainder;
  }
  else // reduced the spoly to 0 ==> add to place "finished_indices"
  {
    token out_finished_indices;
    out_finished_indices.fieldnames[1] = "finished_indices";
    out_finished_indices.data[1] = in_remainder.data[2];
    out_finished_indices.fieldnames[2] = "new_state_for_A";
    out_finished_indices.data[2] = NF_IS_ZERO;
    out_many_finished_indices[1] = out_finished_indices;
  }
  //debug(DIR,ddd,string(ddd)); ddd++;
  time = in_remainder.data[3] + (rtimer-time);
  return(time, out_many_remainder, out_many_finished_indices, out_many_NF); // exactly one list will contain exactly one element, the others will be empty
}

proc NF_of_spoly(string DIR, int read_r, token in_started_indices)
"USAGE: NF_of_spoly(token read_r, token in_started_indices)
RETURN: list out_many_finished_indices, list out_many_NF
"
{
  int time = rtimer;

  int i,j = in_started_indices.data[1];

//  debug(DIR, in_started_indices, "o"+in_started_indices+"o", "%s");
//  int ind = find(in_started_indices,",");
//  int i = int(in_started_indices[1,ind-1]);
//  debug(DIR, i, "o"+in_started_indices+"o_i", "%s");
//  int j = int(in_started_indices[ind+1,size(in_started_indices)]);
//  debug(DIR, j, "o"+in_started_indices+"o_j", "%s");

  list m1 = read("ssi:r "+DIR+"m1");
  int k;
  if(m1[2]==0) {ideal F;}
  else         {module F;}
  for(k=1; k<=read_r; k++)   {F[k] = read("ssi:r "+DIR+"f"+string(k));}

  def p = NF(spoly(F[i],F[j]),F,1);

  list out_many_NF, out_many_finished_indices;
  if(p!=0)
  {
    token out_NF;
    out_NF.fieldnames[1] = "normal_form";
    out_NF.data[1] = p;
    out_NF.fieldnames[2] = "indices";
    out_NF.data[2] = intvec(i,j);
    out_many_NF[1] = out_NF;
  }
  else
  {
    token out_finished_indices;
    out_finished_indices.fieldnames[1] = "finished_indices";
    out_finished_indices.data[1] = intvec(i,j);
    out_finished_indices.fieldnames[2] = "new_state_for_A";
    out_finished_indices.data[2] = NF_IS_ZERO;
    out_many_finished_indices[1] = out_finished_indices;
  }
  return(rtimer-time, out_many_finished_indices, out_many_NF);
}

proc increment(string DIR, token in_NF, token inout_A, int inout_r)
"USAGE: increment(token in_NF, token inout_A, token inout_r)
RETURN: token inout_A, token inout_r, token out_finished_indices
"
{
  int time = rtimer;
  def R = in_NF.r_data;
  setring R;
  def p = in_NF.data[1];
  intvec indices = in_NF.data[2];
  intmat old_A = inout_A.data[1];
  matrix old_B = inout_A.data[2];
  intmat old_D = inout_A.data[3];
  int current_degree = inout_A.data[4];

  list m;
  if(typeof(p)=="vector") // p vector
  {
    int n = nvars(basering);
    intvec e = leadexp(p);
    m[1] = monomial(intvec(e[1..n]));
    m[2] = e[n+1];
  }
  else // p polynomial
  {
    m[1] = leadmonom(p);
    m[2] = 0;
  }
  m[3] = deg(p);
  m[4] = size(p);
  m[5] = ecart(p);

  write("ssi:w "+DIR+"m"+string(inout_r+1), m);
  write("ssi:w "+DIR+"f"+string(inout_r+1), p); // TO DO: dont read in f_{r+1} into SINGULAR but just change the filename in C++ !

  intmat A[inout_r+1][inout_r+1];
  matrix B[inout_r+1][inout_r+1];
  intmat D[inout_r+1][inout_r+1];
  A[1..inout_r,1..inout_r] = old_A[1..inout_r,1..inout_r];
  B[1..inout_r,1..inout_r] = old_B[1..inout_r,1..inout_r];
  D[1..inout_r,1..inout_r] = old_D[1..inout_r,1..inout_r];

  list M;
  int i;
  for(i=1; i<=inout_r; i++) {M[i] = read("ssi:r "+DIR+"m"+string(i));}
  M[inout_r+1] = m;


  //update B,D
  for(i=1; i<=inout_r+1; i++)
  {
    B[i,inout_r+1] = lcm(M[i][1],m[1]);
    B[inout_r+1,i] = B[i,inout_r+1];
    D[i,inout_r+1] = deg(B[i,inout_r+1]);
    D[inout_r+1,i] = D[i,inout_r+1];
  }

  // update A using product (+ chain) criterion
  list kill_indices;
  export(A, B, kill_indices, M);
  int cctime = rtimer;
  product_criterion(inout_r+1);
  cctime = rtimer - cctime;

  for(i=1; i<=inout_r; i++)
  {
    if(A[i,inout_r+1]==0) {current_degree = min(current_degree, D[i,inout_r+1]);}
  }

  inout_A.data[1] = A;
  inout_A.data[2] = B;
  inout_A.data[3] = D;
  inout_A.data[4] = current_degree;
  token out_finished_indices;
  out_finished_indices.fieldnames[1] = "finished_indices";
  out_finished_indices.data[1] = indices;
  out_finished_indices.fieldnames[2] = "new_state_for_A";
  out_finished_indices.data[2] = inout_r+1;
  inout_r++;
  return(inout_A, inout_r, rtimer-time, cctime, current_degree, out_finished_indices, kill_indices);
}

proc write_finished_indices_to_A(string DIR, token in_finished_indices, token inout_A)
"USAGE: write_finished_indices_to_A(token in_finished_indices, token inout_A)
RETURN: token inout_A
"
{
  int time = rtimer;
  intmat A = inout_A.data[1];
  matrix B = inout_A.data[2];
  int i,j = in_finished_indices.data[1];
  int new_state = in_finished_indices.data[2];

  int r = nrows(A); // need this r, not the (potentially bigger) r from place_r!
  list M;
  for(int k=1; k<=r; k++) {M[k] = read("ssi:r "+DIR+"m"+string(k));}
  list kill_indices;
  export(A, B, kill_indices, M);

  int cctime = rtimer;
  //if(A[i,j] == CHAIN_CRITERION && new_state>=2) { // if A[i,j] was CHAIN_CRITERION and a new GB element was created: we now know that we created an unnecessary GB element, so we delete it:
  //  delete_element(new_state);
  //}
  //else {
    A[i,j] = new_state;
    A[j,i] = new_state;
    chain_criterion(i, j);
  //}
  cctime = rtimer-cctime;

  inout_A.data[1] = A;
  return(inout_A, rtimer-time, cctime, kill_indices);
}

proc minimize_GB(string DIR, token in_A, int in_r)
"USAGE: minimize_GB(token in_A, token in_r)
RETURN: token needed_indices_list, token result, int out_reduced_indices_counter, list out_many_needed_indices
"
{
  int time = rtimer;
  list M;
  int k;
  for(k=1; k<=in_r; k++) {M[k] = read("ssi:r "+DIR+"m"+string(k));}

  intvec indices;
  int i,j,needed;
  k=1;
  for(i=1; i<=in_r; i++)
  {
    needed = 1;
    for(j=1; j<=in_r; j++) { if(j!=i) {
      if(M[i][2]==M[j][2] && NF(M[i][1],M[j][1])==0) {
        if(M[i][1]!=M[j][1] || i<j) {
          needed = 0; break;
    }}}}
    if(needed) {indices[k] = i; k++;}
  }
  int final_r = size(indices);

  if(M[1][2]==0) { // ideals
    ideal L;
    for(i=1; i<=final_r; i++) {L[i] = M[indices[i]][1];}
  }
  else { // modules
    module L;
    for(i=1; i<=final_r; i++) {L[i] = M[indices[i]][1]*gen(M[indices[i]][2]);}
  }
  indices = indices[sort(L)[2]]; // sort indices w.r.t. the monomial ordering on the lead monomials (same as SINGULARs 'std')

  token out_needed_indices_list, result;
  out_needed_indices_list.fieldnames[1] = "needed_indices";
  out_needed_indices_list.data[1] = indices;
  result.fieldnames[1] = "final_r";
  result.data[1] = final_r;

  // This output is just for debugging and analysing the algorithm:
    result.fieldnames[2] = "bookkeeping_matrix_A";
    result.data[2] = in_A.data[1];
    result.fieldnames[3] = "bookkeeping_matrix_D";
    result.data[3] = in_A.data[3];
    result.fieldnames[4] = "current_degree";
    result.data[4] = in_A.data[4];
    result.fieldnames[5] = "needed_indices";
    result.data[5] = indices;

  list out_many_needed_indices = indices[1..final_r];
  return(rtimer-time, out_needed_indices_list, result, out_many_needed_indices);
}

proc reduce_GB(string DIR, int read_redSB, token read_needed_indices_list, int in_needed_indices)
"USAGE: reduce_GB(token read_needed_indices_list, token in_needed_indices)
RETURN: nothing (GB will be written in files called g1, g2, g3, ...)
"
{
  int time = rtimer;
  intvec indices = read_needed_indices_list.data[1];
  int r = size(indices);

  int k;
  int n=1;
  if(read_redSB) { // calculate a reduced GB
    def f = read("ssi:r "+DIR+"f"+string(in_needed_indices)); // element to reduce
    if(typeof(f)=="poly") {ideal F;}
    else                  {module F;}

    for(k=1; k<=r; k++)
    {
      if(indices[k]==in_needed_indices) {n = k;}
      else {F[size(F)+1] = read("ssi:r "+DIR+"f"+string(indices[k]));}
    }

    def g = NF(f,F);
  }
  else {
    for(k=1; k<=r; k++) { if(indices[k]==in_needed_indices) {n = k;} }
    def g = read("ssi:r "+DIR+"f"+string(in_needed_indices));
  }

  write("ssi:w "+DIR+"g"+string(n), g/leadcoef(g));
  return(rtimer-time);
}


static proc chain_criterion(int i, int j)
"USAGE: chain_criterion(intmat A, int i, int j, list M)
RETURN: A after applying the chain criterion under the assumption that only the
        entry A_ij has changed (to a 'finished' state); assumes i != j.
"
{
  chain_criterion_row(i,j);
  chain_criterion_col(i,j);
}

static proc delete_element(int i)
"USAGE: delete_element(int i)
RETURN: 'Deletes' the i-th row and column of A (overwrites them with -5)
"
{
  int r = nrows(A);
//  int k;
//  if(i<=r) {
//    for(k=1; k<=r; k++)
//    {
//      if(A[i,k]>=2 && i!=k)
//      {
//        //delete_element(A[i,k]); // recursively delete elements created by the i-th element
//      }
//      else { if(A[i,k] == STARTED) {
//        if(i<k) {kill_indices[size(kill_indices)+1] = string(i,",",k);}
//        else    {kill_indices[size(kill_indices)+1] = string(k,",",i);}
//      }}
//      A[i,k] = UNNECESSARY_ELEMENT; A[k,i] = UNNECESSARY_ELEMENT;
//    }
//  }
}

static proc chain_criterion_row(int i, int j)
"USAGE: chain_criterion(intmat A, int i, int j, list M)
RETURN: A after applying the chain criterion under the assumption that only the
        entry A_ij has changed (to a 'finished' state); assumes i != j.
"
{
  int r = nrows(A);
  int entry;
  for(int k=1; k<=r; k++)
  {
    if(k!=i && k!=j && M[i][2]==M[j][2] && M[j][2]==M[k][2])
    {
      entry = A[i,k];
      if(entry>=2 || entry==NF_IS_ZERO || entry==PRODUCT_CRITERION || entry==CHAIN_CRITERION || entry==DIFFERENT_COMPONENTS)
      {
        //if(NF(lcm(M[j][1],M[k][1]), M[i][1])==0)  // chain-criterion: if (i,k) finished as well and mi divides lcm(mj,mk) then (k,j) can be discarded
        if(NF(B[k,j], M[i][1])==0)  // chain-criterion: if (i,k) finished as well and mi divides lcm(mj,mk) then (k,j) can be discarded
        {
          entry = A[k,j];
          if(entry == STARTED)
          {
            if(k<j) {kill_indices[size(kill_indices)+1] = string(k,",",j);}
            else    {kill_indices[size(kill_indices)+1] = string(j,",",k);}
          }
          if(entry == STARTED || entry == 0)
          {
            A[k,j] = CHAIN_CRITERION; A[j,k] = CHAIN_CRITERION;
            chain_criterion(k,j);
          }
          else { if(entry>=2) { // if A[k,j]>=2: we now know that we created an unnecessary GB element, so we delete it:
            A[k,j] = CHAIN_CRITERION; A[j,k] = CHAIN_CRITERION;
            delete_element(entry);
          }}
        }
      }
    }
  }
}

static proc chain_criterion_col(int i, int j)
"USAGE: chain_criterion(intmat A, int i, int j, list M)
RETURN: A after applying the chain criterion under the assumption that only the
        entry A_ij has changed (to a 'finished' state); assumes i != j.
"
{
  int r = nrows(A);
  int entry;
  for(int k=1; k<=r; k++)
  {
    if(k!=i && k!=j && M[i][2]==M[j][2] && M[j][2]==M[k][2])
    {
      entry = A[k,j];
      if(entry>=2 || entry==NF_IS_ZERO || entry==PRODUCT_CRITERION || entry==CHAIN_CRITERION || entry==DIFFERENT_COMPONENTS)
      {
        //if(NF(lcm(M[i][1],M[k][1]), M[j][1])==0)  // chain-criterion
        if(NF(B[i,k], M[j][1])==0)  // chain-criterion
        {
          entry = A[i,k];
          if(entry == STARTED)
          {
            if(i<k) {kill_indices[size(kill_indices)+1] = string(i,",",k);}
            else    {kill_indices[size(kill_indices)+1] = string(k,",",i);}
          }
          if(entry == STARTED || entry == 0)
          {
            A[i,k] = CHAIN_CRITERION; A[k,i] = CHAIN_CRITERION;
            chain_criterion(i,k);
          }
          else { if(entry>=2) { // if A[i,k]>=2: we now know that we created an unnecessary GB element, so we delete it:
            A[i,k] = CHAIN_CRITERION; A[k,i] = CHAIN_CRITERION;
            delete_element(entry);
          }}
        }
      }
    }
  }
}

static proc product_criterion(int i)
"USAGE: product_criterion(intmat A, intvec is, intvec js, list M)
RETURN: A after applying the product criterion (in the case of ideals) but only
        testing the entries A_ij (and A_ji) for the given integer i and all j<i.
        Also applies chain criterion if possible (due to the changed A_ij's).
        In the module case, test if L(f_i) and L(f_j) are in different components.
"
{
  int r = nrows(A);
  for(int j=1; j<i; j++)
  {
    if(A[i-1,j]==UNNECESSARY_ELEMENT)
      {A[i,j] = UNNECESSARY_ELEMENT; A[j,i] = UNNECESSARY_ELEMENT;}
    else { if(M[1][2]!=0) // module case: check if f_i, f_j have leads in different components
      {
        if(M[i][2]!=M[j][2])
          {A[i,j] = DIFFERENT_COMPONENTS; A[j,i] = DIFFERENT_COMPONENTS;}
      }
      else // ideal case: check product criterion
      {
        if(lcm(M[i][1],M[j][1])==M[i][1]*M[j][1])
        {
          A[i,j] = PRODUCT_CRITERION; A[j,i] = PRODUCT_CRITERION;
          chain_criterion(i, j);
        }
      }
    }
  }
}


// for debugging as error messages wont be pushed to gspc-monitor:
static proc debug(string DIR, def object, def filename, list #)
{
  if(size(#)==0) {#[1]="";}
  if(#[1]!="") {link l=   ":w "+DIR+string(filename); write(l, typeof(object)+": "+sprintf(#[1], object)); close(l);}
  else         {link l="ssi:w "+DIR+string(filename); write(l, object);                                   close(l);}
}
