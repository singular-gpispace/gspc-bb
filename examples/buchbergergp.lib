///////////////////////////////////////
version="version buchbergergp.lib 0.2 Mar 2023 ";
category="Commutative algebra";
info="
LIBRARY: buchbergergp.lib  procedures for Buchbergers algorithm

OVERVIEW:
    This library contains SINGULAR procedures used in the parallel implementation
    of Buchbergers algorithm in the Singular/GPI-Space framework.
    The newstruct type token  must be defined.

    PROCEDURES:
    init(string,token)                           Initialize (NOT including checking product and chain criterion)
    minimize_GB(string, token, int)              compute, which elements can be deleted to get a minimal Groebner Basis (GB)
    reduce_GB(string,int,token,int)              reduce one element of the minimal GB by all the others to compute a reduced GB
";

proc mod_init()
{
    LIB "polylib.lib";
    //LIB "teachstd.lib";
    LIB "general.lib"; // for sort

    system("--ticks-per-sec", 1000);
    newstruct("token", "list fieldnames, list data");
}

// argument order is ALWAYS:
// for inputs:  read  - in  - inout
// for outputs: inout - out - out_many

proc init(string DIR, input)
"USAGE: init(token input)
RETURN: token out_A, token out_r
"
{
/*
  def F_in = input.data[1];
  list m;
  intvec e;
  int i,j;
  list M;

  if(intStrategy()) // make coefficients integers
  {
    number c;
    for(int i=1; i<=size(F_in); i++)
    {
      c = content(F_in[i]);
      if (c!=1)
      {
        F_in[i] = F_in[i]/c;
      }
    }
  }

  def F = sort(F_in)[1];

  int out_r = size(F);

  int n = nvars(basering);
  if(typeof(F) == "module") { // module
    for(i=1; i<=out_r; i++)
    {
      e = leadexp(F[i]);
      m[1] = list(e[1..n]); // lead monomial as poly
      m[2] = e[n+1];        // the lead monomials component as int (0 in case of polynomials & ideals)
      M[i] = m;
    }
  }
  else { // ideal
    for(i=1; i<=out_r; i++)
    {
      e = leadexp(F[i]);
      m[1] = list(e[1..n]);   // lead monomial as poly
      m[2] = 0;               // the lead monomials component as int (0 in case of polynomials & ideals)
      M[i] = m;
    }
  }*/


  //write("ssi:w "+DIR+"GB_for_BB_test.ssi", F);

  token output;
  output.fieldnames[1] = "test_result";
  output.data[1] = 1;

  // This output is just for debugging and analysing the algorithm:
    output.fieldnames[2] = "transition_names";
    output.data[2] = list("total_start_stop", "total_time",   "TRANSITION init TOTAL", "applying criteria in init transition (Buchberger test)", "TRANSITION NF_of_spoly TOTAL", "reading ideal and kStrategy object (static)", "building s-polynomial", "reduction of s-polynomial", "reading ideal for Buchberger test (init)", "reading ideal for Buchberger test", "building kStrategy object for Buchberger test (init)", "building kStrategy object for Buchberger test", "Singular init");
    output.fieldnames[3] = "runtimes_per_transition";
    output.data[3] = list(list(0,-2^31),list(0,0,0),          list(0,0,0),list(0,0,0),list(0,0,0),list(0,0,0),list(0,0,0),list(0,0,0),list(0,0,0),list(0,0,0),list(0,0,0),list(0,0,0),list(0,0,0));
    output.fieldnames[4]="spoly_that_did_not_reduce_to_zero";
    output.data[4] = list(-1,-1);

  return(output);
}

proc abort_BB_test(list BB_test_fail, token output)
{
  output.data[1] = 0;

  output.data[4] = BB_test_fail;

  return(output);
}

proc summarize_runtimes(list times, token output)
"USAGE: summarize_runtimes(list times, token output)
RETURN: token output
"
{
  int B0 = 0;
  for(int l=1; l<=size(times); l++)
  {
    string transition = times[l][1];
    int start = times[l][2];
    int stop  = times[l][3];
    int duration  = times[l][4];
    int count  = times[l][5];

    int k=0;
    int ntransitions = size(output.data[2]);
    for(int i=1; i<=ntransitions; i++)
    {
      if(transition==output.data[2][i]) {k=i; break;}
    }
    if(k==0) {
      k = ntransitions+1;
      output.data[2][k] = transition;
      output.data[3][k] = list(B0,B0,B0);
    }
    output.data[3][k][1] = output.data[3][k][1] + duration;
    output.data[3][k][2] = output.data[3][k][2] + count;
    output.data[3][k][3] = max(output.data[3][k][3], duration);
    if (start != 0) { // only for runtimes of transitions, not extra measurements:
      output.data[3][2][1] = output.data[3][2][1] + duration; // add to total time
      output.data[3][2][2] = output.data[3][2][2] + count; // add to total
      output.data[3][2][3] = max(output.data[3][2][3], duration); // add to total

      output.data[3][1][2] = max(stop, output.data[3][1][2]); // count end of last activated transition as ending of the algorithm
    }
    if(transition=="TRANSITION init TOTAL") {
      output.data[3][1][1] = start; // count start of init transition as beginning of the algorithm
    }
  }
  return(output);
}

proc intStrategy()
{
  return(option(get)[1] % 2^27>=2^26);
}

// for debugging as error messages wont be pushed to gspc-monitor:
static proc debug(string DIR, def object, def filename, list #)
{
  if(size(#)==0) {#[1]="";}
  if(#[1]!="") {link l=   ":a "+DIR+string(filename); write(l, typeof(object)+": "+sprintf(#[1], object)); close(l);}
  else         {link l="ssi:w "+DIR+string(filename); write(l, object);                                    close(l);}
}
